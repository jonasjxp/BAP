# -*- coding: utf-8 -*-
"""DO_ZERO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tbC8oWBxT0G_u0fEzXtkUJXJAC0nt2iI
"""

!apt-get install -y -qq glpk-utils
!apt-get install -y -qq coinor-cbc
!pip install osmnx folium matplotlib networkx

# ============================
# Imports + Pyomo + Instância MD + Plot + Solver
# ============================
import math, time, random
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

from dataclasses import dataclass
from collections import defaultdict
from heapq import heappush, heappop

# Tenta importar Pyomo
try:
    import pyomo.environ as pyo
except ImportError:
    pyo = None
    print("Pyomo não instalado (rode o pip install).")

# Configuração Visual
plt.rcParams["figure.figsize"] = (10, 6)

# ----------------------------
# Instância Multi-Depot + Sink
# ----------------------------
@dataclass
class VRPInstanceMD:
    n: int                # nº clientes
    m: int                # nº garagens (depots)
    K: int                # nº veículos (total)
    Q: int                # capacidade (se for igual p/ todos)
    coords: np.ndarray    # array (m + n + 1, 2) = depots | clients | sink
    dist: np.ndarray      # matriz de distâncias (N x N)
    depots: list          # lista de índices dos depots
    clients: list         # lista de índices dos clientes
    sink: int             # índice do destino final

def make_instance_md(n=20, m=3, K=8, Q=6, seed=42, sink_center=True):
    """
    Índices:
      depots:  0 .. m-1
      clients: m .. m+n-1
      sink:    m+n
    """
    rng = np.random.default_rng(seed)

    depots = rng.uniform(0, 100, size=(m, 2))
    clients = rng.uniform(0, 100, size=(n, 2))
    if sink_center:
        sink = np.array([[50.0, 50.0]])
    else:
        sink = rng.uniform(0, 100, size=(1, 2))

    coords = np.vstack([depots, clients, sink])

    diff = coords[:, None, :] - coords[None, :, :]
    dist = np.sqrt(np.sum(diff**2, axis=2))

    depots_idx  = list(range(m))
    clients_idx = list(range(m, m + n))
    sink_idx    = m + n

    return VRPInstanceMD(
        n=n, m=m, K=K, Q=Q,
        coords=coords, dist=dist,
        depots=depots_idx, clients=clients_idx, sink=sink_idx
    )

def plot_routes_md(inst: VRPInstanceMD, routes, title="Rotas (Multi-Depot → Sink)"):
    """
    routes: lista de rotas, cada rota é uma lista de índices no grafo:
      exemplo: [depot, c1, c2, ..., sink]
    """
    plt.figure()
    colors = plt.cm.tab10(np.linspace(0, 1, max(1, len(routes))))

    # plota arestas das rotas
    for idx, r in enumerate(routes):
        if len(r) < 2:
            continue
        r_coords = inst.coords[r]

        plt.plot(
            r_coords[:, 0], r_coords[:, 1],
            c=colors[idx], linewidth=2, label=f"R{idx+1}", zorder=1
        )

        # seta no meio (só um indicativo de direção)
        if len(r_coords) >= 2:
            mid = max(0, (len(r_coords) - 2) // 2)
            dx = (r_coords[mid+1, 0] - r_coords[mid, 0]) * 0.01
            dy = (r_coords[mid+1, 1] - r_coords[mid, 1]) * 0.01
            plt.arrow(
                r_coords[mid, 0], r_coords[mid, 1], dx, dy,
                color=colors[idx], head_width=2, length_includes_head=True
            )

    # nós: clientes
    clients_xy = inst.coords[inst.clients]
    plt.scatter(clients_xy[:, 0], clients_xy[:, 1], s=90, zorder=2)
    for j, node in enumerate(inst.clients, start=1):
        x, y = inst.coords[node]
        plt.text(x+1, y+1, str(j), fontsize=9, fontweight="bold")

    # nós: depots
    depots_xy = inst.coords[inst.depots]
    plt.scatter(depots_xy[:, 0], depots_xy[:, 1], marker="s", s=140, zorder=3, label="Garagens")
    for d in inst.depots:
        x, y = inst.coords[d]
        plt.text(x+1, y+1, f"D{d}", fontsize=9, fontweight="bold")

    # nó: sink
    sx, sy = inst.coords[inst.sink]
    plt.scatter([sx], [sy], marker="*", s=220, zorder=4, label="Destino (sink)")
    plt.text(sx+1, sy+1, "S", fontsize=10, fontweight="bold")

    plt.title(title)
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()

def get_solver(max_seconds=300):
    """
    Para o B&P, queremos solver LP/MIP disponível.
    No Colab: CBC e GLPK normalmente ok.
    """
    if pyo is None:
        return None, None

    opt = pyo.SolverFactory("cbc")
    if opt.available():
        opt.options["seconds"] = max_seconds
        return "cbc", opt

    opt = pyo.SolverFactory("glpk")
    if opt.available():
        opt.options["tmlim"] = max_seconds
        return "glpk", opt

    return None, None

# --- CRIAÇÃO DA INSTÂNCIA (Multi-Depot → Sink) ---
inst = make_instance_md(n=30, m=3, K=8, Q=30, seed=42, sink_center=True)

# plota só os pontos (sem rotas ainda)
plot_routes_md(inst, [], "Instância MD-VRP (Garagens → Escola)")

"""# Branch-and-Price (heurístico de geração de colunas)
Master relaxado com colunas (rotas garagem → clientes → destino); duais (π, μ);
custo reduzido c̄_r = c_r − ∑_i π_i a_{ir} − μ.
Sementes longas; fallback sem limite de veículos durante a fase LP.

# Formulação para Branch-and-Price (Set Partitioning)

O Branch-and-Price utiliza a decomposição de Dantzig–Wolfe, na qual o problema
mestre seleciona rotas completas previamente geradas.

Modelo Matemático — Branch-and-Price (Set Partitioning)

O problema é decomposto em um Problema Mestre (RMP) e um Subproblema
(Pricing).

# Problema Mestre (Set Partitioning)

Seja Ω o conjunto de todas as rotas viáveis do tipo
garagem → clientes → destino final (sink).

Variáveis:

$$\lambda_r = \begin{cases} 1 & \text{se a rota } r \in \Omega \text{ é selecionada} \\ 0 & \text{caso contrário} \end{cases}$$

Formulação:

$$\min \sum_{r \in \Omega} c_r \lambda_r$$

Sujeito a:

$$\sum_{r \in \Omega} a_{ir} \lambda_r = 1 \quad \forall i \in \mathcal{C}$$

$$\sum_{r \in \Omega} \lambda_r \le K$$

$$\lambda_r \in \{0, 1\}$$

Onde:

*   $\mathcal{C}$ é o conjunto de clientes,
*   $a_{ir} = 1$ se a rota $r$ atende o cliente $i$, e $0$ caso contrário,
*   $c_r$ é o custo total da rota $r$,
*   $K$ é o número máximo de veículos disponíveis.

## Pricing Problem (Subproblema)

O objetivo do subproblema é identificar uma nova rota r′ com custo reduzido
negativo. Esse problema é tipicamente modelado como um Elementary Shortest
Path Problem with Resource Constraints (ESPPRC).

#### Função Objetivo: Minimizar o Custo Reduzido (c̄)

$$
\min \ \bar{c}
= \sum_{(i,j) \in A} c_{ij} x_{ij}
- \sum_{i \in \mathcal{C}} \pi_i \left( \sum_{j \in V} x_{ij} \right)
- \sigma
$$

onde o custo reduzido é composto pelo custo real da rota menos os valores duais
$\pi_i$ associados à cobertura dos clientes visitados e menos o dual $\sigma$
da restrição de frota total.

#### Sujeito a:

**Fluxo na Garagem (Origem):**  
O veículo deve sair exatamente uma vez de uma garagem.

$$
\sum_{j \in V \setminus \mathcal{D}} x_{dj} = 1,
\quad \forall d \in \mathcal{D}
$$

**Fluxo no Destino Final:**  
O veículo deve chegar exatamente uma vez ao destino final.

$$
\sum_{i \in V \setminus \{s\}} x_{is} = 1
$$

**Conservação de Fluxo (Clientes):**  
Se o veículo entra em um cliente $k$, ele deve sair de $k$.

$$
\sum_{i \in V} x_{ik} - \sum_{j \in V} x_{kj} = 0,
\quad \forall k \in \mathcal{C}
$$

**Elementaridade (Visitar no máximo uma vez):**  
Cada cliente pode ser visitado no máximo uma vez na mesma rota.

$$
\sum_{i \in V} x_{ik} \le 1,
\quad \forall k \in \mathcal{C}
$$

**Capacidade e Eliminação de Subciclos:**  
As restrições abaixo garantem que a capacidade do veículo não seja violada e
impedem a formação de subciclos desconectados.

$$
u_j \ge u_i + q_j - M(1 - x_{ij}),
\quad \forall (i,j) \in A, \ j \in \mathcal{C}
$$

$$
q_i \le u_i \le Q,
\quad \forall i \in \mathcal{C}
$$

onde $u_i$ representa a carga acumulada ao visitar o nó $i$, $q_i$ é a demanda
do cliente $i$, $Q$ é a capacidade do veículo e $M$ é uma constante grande
(suficientemente grande, tipicamente $M = Q$).

**Restrições de Domínio:**

$$
x_{ij} \in \{0,1\}, \quad \forall (i,j) \in A
$$

$$
u_i \ge 0
$$
"""

def run_grasp_vrp_md(inst, iterations=50, alpha=0.2, respect_K=False, use_2opt=True):
    """
    Warm-start (pool inicial) via GRASP para instância Multi-Depot -> Sink.

    Rotas geradas no formato do B&P:
      - path: [depot, ..., sink]
      - covered: conjunto de clientes atendidos
      - edges: conjunto de arcos (i,j)
      - load: nº de clientes na rota (assumindo demanda 1)
      - cost: soma das distâncias na rota
      - depot: garagem de início

    Parâmetros:
      - respect_K: se True, para quando atingir K rotas por iteração (pode sobrar cliente).
                   Se False, gera quantas rotas forem necessárias para cobrir todos os clientes.
      - use_2opt: aplica 2-opt aberto (endpoints fixos depot e sink).
    """
    print(f"--- Iniciando Warm-Up GRASP MD ({iterations} iterações, alpha={alpha}) ---")

    generated_routes = []
    unique_paths = set()

    depots = list(inst.depots)
    clients_all = list(inst.clients)
    clients_set = set(clients_all)
    sink = inst.sink

    for _ in range(iterations):
        unvisited = set(clients_all)
        num_routes = 0

        while unvisited:
            num_routes += 1
            if respect_K and num_routes > inst.K:
                break

            depot = random.choice(depots)

            path = [depot]
            curr = depot
            load = 0  # demanda 1 por cliente

            while True:
                if load + 1 > inst.Q:
                    break

                # candidatos (clientes ainda não visitados)
                candidates = [(inst.dist[curr, node], node) for node in unvisited]
                if not candidates:
                    break

                candidates.sort(key=lambda x: x[0])
                min_dist = candidates[0][0]
                threshold = min_dist * (1 + alpha)

                rcl = [c for c in candidates if c[0] <= threshold]
                _, chosen_node = random.choice(rcl)

                path.append(chosen_node)
                load += 1
                curr = chosen_node
                unvisited.remove(chosen_node)

            # fecha no sink (rota aberta)
            path.append(sink)

            # 2-opt aberto (mantém depot e sink fixos)
            final_path = improve_route_2opt_open(path, inst.dist) if use_2opt else path

            path_tuple = tuple(final_path)
            if path_tuple in unique_paths:
                continue
            unique_paths.add(path_tuple)

            cost = sum(inst.dist[final_path[k], final_path[k + 1]] for k in range(len(final_path) - 1))
            edges = {(final_path[k], final_path[k + 1]) for k in range(len(final_path) - 1)}

            # clientes cobertos = nós do caminho que são clientes
            covered = set(final_path).intersection(clients_set)

            route_dict = {
                "path": list(final_path),
                "cost": float(cost),
                "edges": edges,
                "covered": covered,
                "load": int(len(covered)),  # demanda 1 por cliente
                "depot": int(depot),
            }
            generated_routes.append(route_dict)

    print(f"   -> GRASP gerou {len(generated_routes)} colunas únicas.")
    return generated_routes

def improve_route_2opt_open(path, dist_matrix):
    """
    Aplica 2-opt em um caminho ABERTO [start, ..., end],
    mantendo start e end fixos (ex.: [depot, ..., sink]).
    """
    if len(path) < 4:
        return path  # precisa ter pelo menos 2 arestas internas

    best_path = path[:]
    improved = True

    while improved:
        improved = False

        # Não mexe no primeiro (0) nem no último (-1)
        # então i começa em 1 e j vai até len-3
        for i in range(1, len(best_path) - 2):
            for j in range(i + 1, len(best_path) - 1):
                if j - i == 1:
                    continue  # segmento muito curto, não muda nada

                u, v = best_path[i - 1], best_path[i]
                x, y = best_path[j], best_path[j + 1]

                current_cost = dist_matrix[u, v] + dist_matrix[x, y]
                new_cost     = dist_matrix[u, x] + dist_matrix[v, y]

                if new_cost < current_cost - 1e-4:
                    # inverte o segmento i..j
                    best_path[i:j + 1] = best_path[i:j + 1][::-1]
                    improved = True

    return best_path

def solve_exact_pricing_md(inst, pi_cover, pi_fleet, forbidden_arcs, forced_arcs, Q, time_limit=120):
    """
    Pricing exato (MIP) para rota ABERTA: depot -> ...clientes... -> sink
    em instância multi-depot.

    - pi_cover: dict {cliente_node: dual} (somente clientes)
    - pi_fleet: dual da restrição de frota (escala do mestre)
    - forbidden_arcs / forced_arcs: sets de arcos (i,j) no índice global do inst
    - Q: capacidade (assumindo demanda 1 por cliente)
    """
    if pyo is None:
        return None, 0.0

    depots = list(inst.depots)
    clients = list(inst.clients)
    sink = inst.sink

    # nós relevantes para o pricing (não precisa permitir sair do sink)
    nodes = depots + clients + [sink]

    # --- Filtragem de arcos com Forbidden/Forced ---
    forced_out = {}
    forced_in = {}
    for (u, v) in forced_arcs:
        forced_out[u] = v
        forced_in[v] = u

    valid_arcs = []
    for i in nodes:
        for j in nodes:
            if i == j:
                continue

            # regras estruturais úteis (evita lixo):
            # - ninguém sai do sink
            if i == sink:
                continue
            # - ninguém entra em depósito (rota começa no depósito)
            if j in depots:
                continue
            # - do depósito pode ir para cliente ou sink
            # - de cliente pode ir para cliente ou sink

            # Forbidden
            if (i, j) in forbidden_arcs:
                continue
            # Forced out
            if i in forced_out and forced_out[i] != j:
                continue
            # Forced in
            if j in forced_in and forced_in[j] != i:
                continue

            valid_arcs.append((i, j))

    m = pyo.ConcreteModel()
    m.A = pyo.Set(initialize=valid_arcs, dimen=2)
    m.x = pyo.Var(m.A, within=pyo.Binary)

    # u só para clientes (carga acumulada ao visitar cliente)
    m.u = pyo.Var(clients, within=pyo.NonNegativeReals, bounds=(0, Q))

    # --- Objetivo: custo reduzido ---
    def red_cost_rule(model):
        real = sum(inst.dist[i, j] * model.x[i, j] for (i, j) in model.A)

        # ganhos dos duais de cobertura: conta 1 vez quando "entra" no cliente (incoming)
        gains = 0.0
        for c in clients:
            dual = pi_cover.get(c, 0.0)
            incoming_c = sum(model.x[i, c] for i in nodes if (i, c) in model.A)
            gains += dual * incoming_c

        return real - gains - float(pi_fleet)

    m.obj = pyo.Objective(rule=red_cost_rule, sense=pyo.minimize)

    m.cons = pyo.ConstraintList()

    # --- Escolha de uma garagem de partida: exatamente 1 saída total de depots ---
    m.cons.add(
        sum(m.x[d, j] for d in depots for j in (clients + [sink]) if (d, j) in m.A) == 1
    )

    # --- Chegada ao sink: exatamente 1 entrada no sink ---
    m.cons.add(
        sum(m.x[i, sink] for i in (depots + clients) if (i, sink) in m.A) == 1
    )

    # --- Conservação + elementaridade nos clientes ---
    for k in clients:
        incoming = sum(m.x[i, k] for i in depots + clients if (i, k) in m.A)
        outgoing = sum(m.x[k, j] for j in clients + [sink] if (k, j) in m.A)
        m.cons.add(incoming == outgoing)
        m.cons.add(incoming <= 1)  # visita no máximo uma vez

    # --- MTZ / Capacidade (demanda 1 por cliente) ---
    # Se i->j é usado (e j é cliente), então u[j] >= u[i] + 1, com u[i]=0 quando i é depósito.
    for (i, j) in valid_arcs:
        if j in clients:
            if i in clients:
                m.cons.add(m.u[j] >= m.u[i] + 1 - Q * (1 - m.x[i, j]))
            elif i in depots:
                # saindo do depósito para primeiro cliente: u[j] >= 1 se arco ativo
                m.cons.add(m.u[j] >= 1 - Q * (1 - m.x[i, j]))

    # limites inferiores coerentes (se cliente é visitado, u >= 1; se não, pode ficar 0)
    for c in clients:
        inc = sum(m.x[i, c] for i in depots + clients if (i, c) in m.A)
        m.cons.add(m.u[c] >= inc)          # se visitou, u>=1
        m.cons.add(m.u[c] <= Q * inc)      # se não visitou, u=0

    # --- Resolver ---
    _, solver = get_solver(max_seconds=time_limit)
    if not solver:
        return None, 0.0

    solver.solve(m, tee=False)
    min_rc_val = pyo.value(m.obj)

    # Se achou coluna com custo reduzido negativo, reconstrói caminho depot->...->sink
    if min_rc_val is not None and min_rc_val < -1e-5:
        # encontra o depósito inicial (único arco saindo de depots)
        start = None
        for d in depots:
            for j in clients + [sink]:
                if (d, j) in valid_arcs and pyo.value(m.x[d, j]) > 0.5:
                    start = d
                    break
            if start is not None:
                break
        if start is None:
            return None, float(min_rc_val)

        path = [start]
        curr = start
        visited_edges = set()

        while curr != sink:
            nxt = None
            for j in clients + [sink]:
                if (curr, j) in valid_arcs and pyo.value(m.x[curr, j]) > 0.5:
                    nxt = j
                    break
            if nxt is None:
                break
            if (curr, nxt) in visited_edges:
                break
            visited_edges.add((curr, nxt))
            path.append(nxt)
            curr = nxt

        # valida que terminou no sink
        if path[-1] != sink:
            return None, float(min_rc_val)

        real_cost = sum(inst.dist[path[k], path[k + 1]] for k in range(len(path) - 1))
        edges = {(path[k], path[k + 1]) for k in range(len(path) - 1)}
        covered = set(path).intersection(set(clients))

        col = {
            "path": path,
            "cost": float(real_cost),
            "edges": edges,
            "covered": covered,
            "load": int(len(covered)),   # demanda 1
            "depot": int(path[0]),
        }
        return col, float(min_rc_val)

    return None, float(min_rc_val if min_rc_val is not None else 0.0)

class BPNode:
    def __init__(self, nid, parent=None, forbidden=None, forced=None):
        self.id = nid
        self.parent = parent

        self.forbidden = set(forbidden) if forbidden is not None else set()
        self.forced = set(forced) if forced is not None else set()

        self.lb = -float("inf")     # lower bound do nó (valor do RMP relaxado)
        self.lam_sol = {}           # solução do mestre: {route_id: lambda_value}
        self.x_bar = {}             # arcos agregados derivados do lambda: {(i,j): val}

    def __lt__(self, other):
        return self.lb < other.lb

def solve_node_md(
    inst,
    node,
    global_routes,
    alpha=0.5,
    gap_tol=0.005,
    time_limit=900,
    max_cg_iter=10000,
    BIG=1e6,
    M_PENALTY=100000.0,
):
    """
    Resolve um nó do B&P via Column Generation (RMP + pricing heurístico + fallback exato),
    com branching via forbidden/forced arcs, para instância Multi-Depot -> Sink.
    """

    start_time = time.time()

    depots = list(inst.depots)
    clients = list(inst.clients)
    clients_set = set(clients)
    sink = inst.sink

    all_nodes = depots + clients + [sink]

    # 1) Matriz de custo alterada para respeitar branching no pricing heurístico (e 2-opt)
    dist_h = inst.dist.copy()

    for (u, v) in node.forbidden:
        dist_h[u, v] = BIG

    for (u, v) in node.forced:
        # se u->v é forçado: proíbe u->k (k!=v) e k->v (k!=u)
        for k in all_nodes:
            if k != v:
                dist_h[u, k] = BIG
            if k != u:
                dist_h[k, v] = BIG

    loop_cols = True
    iter_cg = 0

    # estabilização de duais
    pi_cov_stab = {c: 0.0 for c in clients}
    pi_flt_stab = 0.0
    first_iter = True

    best_lb = 0.0
    best_gap = float("inf")

    while loop_cols and iter_cg < max_cg_iter and (time.time() - start_time) < time_limit:
        iter_cg += 1

        # -------- RMP --------
        rmp = pyo.ConcreteModel()

        # Filtra rotas válidas (respeitam forbidden/forced)
        valid_idx = []
        for idx, r in enumerate(global_routes):
            if not r["edges"].isdisjoint(node.forbidden):
                continue

            ok = True
            p = r["path"]

            # forced: se u aparece, o próximo deve ser v; se v aparece, o anterior deve ser u
            for (u, v) in node.forced:
                if u in p[:-1]:
                    if p[p.index(u) + 1] != v:
                        ok = False
                        break
                if v in p[1:]:
                    if p[p.index(v) - 1] != u:
                        ok = False
                        break

            if ok:
                valid_idx.append(idx)

        rmp.I = pyo.Set(initialize=valid_idx)

        rmp.lam = pyo.Var(rmp.I, within=pyo.NonNegativeReals)
        rmp.slk_cov = pyo.Var(clients, within=pyo.NonNegativeReals)  # slack cobertura
        rmp.slk_flt = pyo.Var(within=pyo.NonNegativeReals)           # slack frota

        rmp.obj = pyo.Objective(
            expr=(
                sum(global_routes[i]["cost"] * rmp.lam[i] for i in rmp.I)
                + sum(M_PENALTY * rmp.slk_cov[c] for c in clients)
                + M_PENALTY * rmp.slk_flt
            ),
            sense=pyo.minimize
        )

        # cobertura (set partitioning)
        rmp.c_cov = pyo.ConstraintList()
        for c in clients:
            rmp.c_cov.add(
                sum(rmp.lam[i] for i in rmp.I if c in global_routes[i]["covered"])
                + rmp.slk_cov[c]
                == 1
            )

        # frota (mantendo seu estilo == K com slack)
        rmp.c_flt = pyo.Constraint(
            expr=sum(rmp.lam[i] for i in rmp.I) + rmp.slk_flt == inst.K
        )

        rmp.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)

        _, solver = get_solver(max_seconds=60)
        if not solver:
            return False

        res = solver.solve(rmp, tee=False)
        if res.solver.termination_condition != pyo.TerminationCondition.optimal:
            node.lb = float("inf")
            return True

        current_obj = float(pyo.value(rmp.obj))

        # 2) duais
        try:
            # c_cov é ConstraintList: indexa começando em 1 na ordem que foi adicionada.
            # Então precisamos mapear cliente -> constraint.
            # Vamos reconstruir lendo na mesma ordem:
            pi_cov_curr = {}
            for idx_c, c in enumerate(clients, start=1):
                pi_cov_curr[c] = float(rmp.dual[rmp.c_cov[idx_c]])
            pi_flt_curr = float(rmp.dual[rmp.c_flt])
        except Exception:
            node.lb = float("inf")
            return True

        print(
            f"Node: {node.id} / Iter: {iter_cg} / UB(obj): {current_obj:.2f} "
            f"/ bestLB: {best_lb:.2f} / bestGap: {best_gap:.4f} / Solver: {_}"
        )

        # 3) estabilização (smoothing)
        if first_iter:
            pi_cov_stab = pi_cov_curr.copy()
            pi_flt_stab = pi_flt_curr
            first_iter = False
        else:
            for c in clients:
                pi_cov_stab[c] = alpha * pi_cov_curr[c] + (1 - alpha) * pi_cov_stab[c]
            pi_flt_stab = alpha * pi_flt_curr + (1 - alpha) * pi_flt_stab

        pi_cov_use = pi_cov_stab
        pi_flt_use = pi_flt_stab

        # -------- Pricing heurístico --------
        new_col = False

        # seeds = clientes como primeiro cliente (opcional); aqui vou tentar vários starts (clientes)
        seeds = clients[:]
        random.shuffle(seeds)

        for first_client in seeds:
            # escolhe um depot para começar
            depot = random.choice(depots)

            # se arco depot->first_client proibido, pula
            if dist_h[depot, first_client] > BIG / 2:
                continue

            path = [depot, first_client]
            vis = {first_client}
            load = 1
            cost = dist_h[depot, first_client]
            curr = first_client

            if load > inst.Q:
                continue

            while load < inst.Q:
                # tenta “fechar” indo ao sink
                close_c = dist_h[curr, sink]
                if close_c < BIG / 2:
                    rc_path = (cost + close_c) - sum(pi_cov_use[x] for x in vis) - pi_flt_use
                    if rc_path < -1e-2:
                        raw_p = path + [sink]
                        opt_p = improve_route_2opt_open(raw_p, dist_h)

                        edges_opt = {(opt_p[k], opt_p[k + 1]) for k in range(len(opt_p) - 1)}
                        if edges_opt.isdisjoint(node.forbidden):
                            real_cost = sum(inst.dist[opt_p[k], opt_p[k + 1]] for k in range(len(opt_p) - 1))
                            covered = set(opt_p).intersection(clients_set)

                            global_routes.append({
                                "path": opt_p,
                                "cost": float(real_cost),
                                "edges": edges_opt,
                                "covered": covered,
                                "load": int(len(covered)),
                                "depot": int(opt_p[0]),
                            })
                            new_col = True

                # escolhe próximo cliente por “dist - dual”
                bst_n = None
                bst_val = float("inf")
                for nxt in clients:
                    if nxt not in vis and dist_h[curr, nxt] < BIG / 2:
                        val = dist_h[curr, nxt] - pi_cov_use.get(nxt, 0.0)
                        if val < bst_val:
                            bst_val = val
                            bst_n = nxt

                # critério parecido com o seu
                if bst_n is not None and (bst_val < 1.0 or len(path) < 3):
                    path.append(bst_n)
                    vis.add(bst_n)
                    cost += dist_h[curr, bst_n]
                    curr = bst_n
                    load += 1
                else:
                    break

        # -------- Pricing exato (fallback) --------
        if not new_col:
            ex_col, min_rc = solve_exact_pricing_md(
                inst,
                pi_cover=pi_cov_curr,
                pi_fleet=pi_flt_curr,
                forbidden_arcs=node.forbidden,
                forced_arcs=node.forced,
                Q=inst.Q,
                time_limit=120
            )

            if min_rc > -1e-5:
                loop_cols = False
                lagrangian_lb = current_obj
            else:
                lagrangian_lb = current_obj + inst.K * min_rc

            best_lb = max(best_lb, lagrangian_lb)

            gap = 0.0
            if current_obj > 1e-6:
                gap = (current_obj - lagrangian_lb) / current_obj
            best_gap = min(best_gap, gap)

            if ex_col:
                global_routes.append(ex_col)
                new_col = True

            if gap < gap_tol and current_obj < 1e10:
                loop_cols = False

        loop_cols = new_col if loop_cols else False

        # -------- Encerrando nó: salva LB e x_bar (arcos agregados) --------
        if not loop_cols:
            node.lb = float(pyo.value(rmp.obj))

            # checa penalidade (slacks)
            pen = float(sum(pyo.value(rmp.slk_cov[c]) for c in clients) + pyo.value(rmp.slk_flt))
            if pen > 1e-3:
                node.lb = float("inf")

            # salva solução de arcos agregada (para branching)
            node.x_sol = defaultdict(float)
            for i in valid_idx:
                val = float(pyo.value(rmp.lam[i]))
                if val > 1e-4:
                    p = global_routes[i]["path"]
                    for k in range(len(p) - 1):
                        node.x_sol[(p[k], p[k + 1])] += val

    return True

def solve_full_branch_and_price_md(inst, alpha=0.5, gap_tol=0.005, time_limit=900, max_cg_iter=10000):
    print(f"--- B&P Iniciado (MD-OVRP -> Sink, Q={inst.Q}) ---")
    start_time = time.time()

    depots = list(inst.depots)
    clients = list(inst.clients)
    sink = inst.sink

    # -------------------------
    # Pool Global de rotas
    # -------------------------
    global_routes = []

    # 1) Rotas pendulares iniciais: depot -> cliente -> sink
    # (gera uma por cliente, escolhendo o melhor depot para aquele cliente)
    for c in clients:
        best_d = None
        best_cost = float("inf")
        for d in depots:
            val = inst.dist[d, c] + inst.dist[c, sink]
            if val < best_cost:
                best_cost = val
                best_d = d

        path = [best_d, c, sink]
        edges = {(best_d, c), (c, sink)}
        global_routes.append({
            "path": path,
            "cost": float(best_cost),
            "edges": edges,
            "covered": {c},
            "load": 1,
            "depot": int(best_d)
        })

    # 2) Warm-up GRASP multi-depot -> sink
    grasp_cols = run_grasp_vrp_md(inst, iterations=100, alpha=0.2, respect_K=False, use_2opt=True)
    global_routes.extend(grasp_cols)

    # -------------------------
    # Árvore B&B
    # -------------------------
    root = BPNode(0, parent=-1, forbidden=[], forced=[])
    pq = []

    solve_node_md(inst, root, global_routes, alpha=alpha, gap_tol=gap_tol, time_limit=time_limit, max_cg_iter=max_cg_iter)
    heappush(pq, root)

    best_int_val = float("inf")
    cnt = 0

    while pq:
        if time.time() - start_time > time_limit:
            break

        node = heappop(pq)

        if node.lb >= best_int_val or node.lb == float("inf"):
            continue

        print(f"Node {node.id}: LB={node.lb:.2f}")

        # Escolhe arco fracionário mais perto de 0.5 (arc branching)
        frac_arc = None
        closest = float("inf")
        for (u, v), val in node.x_sol.items():
            # ignora arcos já inteiros
            if abs(val - round(val)) <= 1e-3:
                continue
            # ignora arcos estruturalmente inválidos (opcional, mas ajuda)
            if u == sink:
                continue
            if v in depots:
                continue

            dist_to_half = abs(val - 0.5)
            if dist_to_half < closest:
                closest = dist_to_half
                frac_arc = (u, v)

        if frac_arc is None:
            # nó “inteiro” no agregado de arcos (não garante λ inteiro, mas é um bom sinal)
            print(f"  -> Sem arco fracionário detectado. LB={node.lb:.2f}")
            if node.lb < best_int_val:
                best_int_val = node.lb
            continue

        u, v = frac_arc
        print(f"  -> Branching no arco ({u},{v})")

        # Filho 0: proíbe o arco
        cnt += 1
        child0 = BPNode(cnt, parent=node.id, forbidden=node.forbidden | {(u, v)}, forced=node.forced)
        solve_node_md(inst, child0, global_routes, alpha=alpha, gap_tol=gap_tol, time_limit=time_limit, max_cg_iter=max_cg_iter)
        if child0.lb < best_int_val:
            heappush(pq, child0)

        # Filho 1: força o arco
        cnt += 1
        child1 = BPNode(cnt, parent=node.id, forbidden=node.forbidden, forced=node.forced | {(u, v)})
        solve_node_md(inst, child1, global_routes, alpha=alpha, gap_tol=gap_tol, time_limit=time_limit, max_cg_iter=max_cg_iter)
        if child1.lb < best_int_val:
            heappush(pq, child1)

    # -------------------------
    # Mestre final INTEIRO (IP)
    # -------------------------
    print("\n--- IP Final (Set Partitioning) ---")

    rmp_f = pyo.ConcreteModel()
    I = list(range(len(global_routes)))

    rmp_f.I = pyo.Set(initialize=I)
    rmp_f.lam = pyo.Var(rmp_f.I, within=pyo.Binary)
    rmp_f.slk_flt = pyo.Var(within=pyo.NonNegativeReals)

    BIGP = 1e5
    rmp_f.obj = pyo.Objective(
        expr=sum(global_routes[i]["cost"] * rmp_f.lam[i] for i in rmp_f.I) + BIGP * rmp_f.slk_flt,
        sense=pyo.minimize
    )

    rmp_f.cov = pyo.ConstraintList()
    for c in clients:
        rmp_f.cov.add(
            sum(rmp_f.lam[i] for i in rmp_f.I if c in global_routes[i]["covered"]) == 1
        )

    # frota final: mantendo seu padrão == K (com slack)
    rmp_f.flt = pyo.Constraint(expr=sum(rmp_f.lam[i] for i in rmp_f.I) + rmp_f.slk_flt == inst.K)

    _, s = get_solver(max_seconds=600)
    if not s:
        return float("inf"), []

    s.solve(rmp_f, tee=False)

    final_routes = []
    if pyo.value(rmp_f.obj) < BIGP:
        for i in I:
            if pyo.value(rmp_f.lam[i]) > 0.5:
                final_routes.append(global_routes[i]["path"])

    total_time = time.time() - start_time
    print(f"Tempo de execução Branch-and-Price: {total_time:.2f}s")

    return float(pyo.value(rmp_f.obj)), final_routes

# --- CRIAÇÃO DA INSTÂNCIA (Multi-Depot → Sink) ---
inst = make_instance_md(
    n=15,     # número de clientes
    m=3,      # número de garagens
    K=4,      # frota total
    Q=7,      # capacidade do veículo
    seed=37,
    sink_center=True
)

# Plota apenas os nós (sem rotas ainda)
plot_routes_md(inst, [], "Instância MD-VRP (Garagens → Destino Final)")

print("\n === BRANCH-AND-PRICE (MD → SINK) ===")
cost_bp, routes_bp = solve_full_branch_and_price_md(
    inst,
    alpha=0.5,
    gap_tol=0.01,
    time_limit=3600,
    max_cg_iter=10000
)

plot_routes_md(inst, routes_bp, f"Branch-and-Price MD→Sink (Q={inst.Q}) - Custo {cost_bp:.2f}")

import osmnx as ox
import networkx as nx
import random
import numpy as np
from shapely.geometry import Point
from dataclasses import dataclass

ox.settings.use_cache = True
ox.settings.log_console = False

@dataclass
class RealWorldMDInstance:
    n: int
    m: int
    K: int
    Q: int
    G: any
    depots: list      # índices globais dos depósitos
    clients: list     # índices globais dos clientes
    sink: int         # índice global do sink
    map_idx_to_node: dict  # índice global -> nó OSM
    dist: np.ndarray       # matriz NxN (global indices 0..N-1)


def build_realworld_md_instance(
    n_clients=12,
    m_depots=3,
    city_query="Fortaleza, Ceara, Brazil",
    radius_meters=1500,
    seed=42,
    Q=5,
    K=4,
    school_as_sink=True,  # se True, sink = escola; senão escolhe outro nó
):
    random.seed(seed)
    np.random.seed(seed)

    # 1) Escolhe uma escola (como no seu código)
    tags = {'amenity': 'school'}
    try:
        gdf = ox.features_from_place(city_query, tags)
        school_feature = gdf.sample(1).iloc[0]
        depot_point = school_feature.geometry.centroid
        school_name = school_feature.get('name', 'Escola (Sem Nome)')
    except Exception:
        depot_point = Point(-38.527, -3.730)
        school_name = "Escola Exemplo (Centro)"

    print(f"Escola selecionada: {school_name}")
    print(f"Baixando malha viária (raio {radius_meters}m)...")

    G = ox.graph_from_point(
        (depot_point.y, depot_point.x),
        dist=radius_meters,
        network_type='drive'
    )

    # nó OSM mais próximo da escola
    school_node = ox.nearest_nodes(G, depot_point.x, depot_point.y)

    # 2) Sorteia nós para garagens e clientes
    all_nodes = list(G.nodes)
    if school_node in all_nodes:
        all_nodes.remove(school_node)

    # garante que tem nós suficientes
    needed = m_depots + n_clients + (0 if school_as_sink else 1)
    if len(all_nodes) < needed:
        raise ValueError("Poucos nós no grafo para sortear depots/clients/sink. Aumente radius_meters.")

    chosen = random.sample(all_nodes, m_depots + n_clients + (0 if school_as_sink else 1))

    depot_nodes = chosen[:m_depots]
    client_nodes = chosen[m_depots:m_depots + n_clients]

    if school_as_sink:
        sink_node = school_node
    else:
        sink_node = chosen[-1]

    # 3) Indexação global: [depots | clients | sink]
    # índices globais: 0..m-1 depots; m..m+n-1 clientes; m+n sink
    depots = list(range(m_depots))
    clients = list(range(m_depots, m_depots + n_clients))
    sink = m_depots + n_clients
    N = sink + 1

    map_idx_to_node = {}
    for i, osm_node in enumerate(depot_nodes):
        map_idx_to_node[i] = osm_node
    for k, osm_node in enumerate(client_nodes):
        map_idx_to_node[m_depots + k] = osm_node
    map_idx_to_node[sink] = sink_node

    # 4) Matriz de distâncias (Dijkstra)
    print("Calculando matriz de distâncias reais (Dijkstra)...")
    dist = np.full((N, N), 1e6, dtype=float)
    np.fill_diagonal(dist, 0.0)

    # dica: calcular por fonte melhora performance
    for i in range(N):
        u = map_idx_to_node[i]
        # single_source_dijkstra_path_length é mais rápido para todos destinos
        lengths = nx.single_source_dijkstra_path_length(G, u, weight="length")
        for j in range(N):
            v = map_idx_to_node[j]
            if v in lengths:
                dist[i, j] = float(lengths[v])

    print("Instância MD→Sink pronta!")
    return RealWorldMDInstance(
        n=n_clients, m=m_depots, K=K, Q=Q, G=G,
        depots=depots, clients=clients, sink=sink,
        map_idx_to_node=map_idx_to_node,
        dist=dist
    )

import folium
import networkx as nx

def plot_solution_on_map_md(inst, routes, school_name="Escola (Sink)"):
    """
    Plota rotas abertas (depot -> ... -> sink) no mapa Folium,
    para instância RealWorldMDInstance (multi-depot -> sink).

    inst deve ter:
      - inst.G (grafo OSMnx)
      - inst.depots (lista de índices globais)
      - inst.clients (lista de índices globais)
      - inst.sink (índice global do sink)
      - inst.map_idx_to_node (global idx -> nó OSM)
    routes: lista de paths no formato [depot, ..., sink]
    """
    G = inst.G
    sink_idx = inst.sink
    sink_node = inst.map_idx_to_node[sink_idx]

    # centro do mapa = escola/sink
    lat0 = G.nodes[sink_node]['y']
    lon0 = G.nodes[sink_node]['x']
    m = folium.Map(location=[lat0, lon0], zoom_start=14, tiles='CartoDB positron')

    # --- marcador do SINK (Escola) ---
    folium.Marker(
        location=[lat0, lon0],
        popup=f"<b>Sink (Escola)</b>: {school_name}",
        icon=folium.Icon(color='black', icon='graduation-cap', prefix='fa')
    ).add_to(m)

    # --- marcadores das GARAGENS ---
    for d_idx in inst.depots:
        d_node = inst.map_idx_to_node[d_idx]
        lat = G.nodes[d_node]['y']
        lon = G.nodes[d_node]['x']
        folium.Marker(
            location=[lat, lon],
            popup=f"<b>Garagem</b> (idx={d_idx})",
            icon=folium.Icon(color='blue', icon='home', prefix='fa')
        ).add_to(m)

    # cores
    colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'cadetblue']

    # --- desenha rotas ---
    for ridx, route in enumerate(routes):
        if not route or route[0] not in inst.depots or route[-1] != sink_idx:
            # ignora rota mal formatada
            continue

        col = colors[ridx % len(colors)]
        route_group = folium.FeatureGroup(name=f"Rota {ridx+1} (clientes={len(route)-2})")

        # marcador do primeiro nó (garagem) já existe, mas podemos destacar a saída
        d_node = inst.map_idx_to_node[route[0]]
        folium.CircleMarker(
            location=[G.nodes[d_node]['y'], G.nodes[d_node]['x']],
            radius=6, color=col, fill=True, fill_opacity=0.9,
            popup=f"Saída: Garagem {route[0]}"
        ).add_to(route_group)

        # para cada arco no path: desenha o menor caminho no grafo
        for k in range(len(route) - 1):
            u_idx = route[k]
            v_idx = route[k + 1]
            u_node = inst.map_idx_to_node[u_idx]
            v_node = inst.map_idx_to_node[v_idx]

            # marca clientes (nós intermediários do path)
            if u_idx in inst.clients:
                pt = G.nodes[u_node]
                folium.CircleMarker(
                    location=[pt['y'], pt['x']],
                    radius=5, color=col, fill=True, fill_opacity=0.7,
                    popup=f"Cliente {u_idx}"
                ).add_to(route_group)

            # desenha a geometria do caminho real
            try:
                path_nodes = nx.shortest_path(G, u_node, v_node, weight='length')
                path_coords = [[G.nodes[n]['y'], G.nodes[n]['x']] for n in path_nodes]
                folium.PolyLine(path_coords, color=col, weight=4, opacity=0.8).add_to(route_group)
            except nx.NetworkXNoPath:
                # sem caminho, não desenha esse trecho
                pass

        route_group.add_to(m)

    folium.LayerControl().add_to(m)
    return m

inst = build_realworld_md_instance(
    n_clients=12, m_depots=3,
    city_query="Fortaleza, Ceara, Brazil",
    radius_meters=1500,
    seed=42,
    Q=5, K=4,
    school_as_sink=True
)

cost, routes = solve_full_branch_and_price_md(inst, time_limit=900, gap_tol=0.01)

mapa = plot_solution_on_map_md(inst, routes, school_name="Escola (Sink)")
mapa